// Import components
import './vibe-coder-header.js';
import './vibe-coder-chat-message.js';
import './vibe-coder-chat-input.js';
import './vibe-coder-chat.js';
import './vibe-coder-canvas.js';
import './vibe-coder-controls.js';
import './vibe-coder-app.js';
import './vibe-coder-mode-selector.js';
import {fetchGemini} from '../js/llm-tools.js';
import { MODES } from './modes.js';

let currentMode = MODES[0];

const SYSTEM_PROMPT = currentMode.systemPrompt;

let componentData = {};

function saveToStorage() {
    localStorage.setItem('vibe-coder-components', JSON.stringify(componentData));
}

function loadFromStorage() {
    const saved = localStorage.getItem('vibe-coder-components');
    if (saved) {
        try {
            const data = JSON.parse(saved);
            Object.keys(data).forEach(tag => {
                register(data[tag].code, false);
            });
        } catch (e) {
            console.error('Failed to load components from storage', e);
        }
    }
}

function getInputType(attr) {
    const lower = attr.toLowerCase();
    if (lower.includes('color')) return 'color';
    if (lower.includes('number') || lower.includes('size') || lower.includes('width') || lower.includes('height') || lower.includes('duration')) return 'number';
    if (lower.includes('date')) return 'date';
    if (lower.includes('time')) return 'time';
    return 'text';
}

async function fetchAI(prompt) {

    let retries = 0;
    const delays = [1000, 2000, 4000, 8000, 16000];

    while (retries < 5) {
        try {
            const data = await fetchGemini(prompt, currentMode.systemPrompt);
            return data.candidates?.[0]?.content?.parts?.[0]?.text || "";
        } catch (e) {
            await new Promise(res => setTimeout(res, delays[retries]));
            retries++;
        }
    }
    return "Error: Failed to fetch response after retries.";
}

function register(js, shouldSave = true) {
    try {
        const match = js.match(/customElements\.define\(['"]([^'"]+)['"]/);
        if (!match) return null;
        const tag = match[1];

        if (customElements.get(tag)) {
            const el = document.createElement(tag);
            const attrs = el.constructor.observedAttributes || [];
            componentData[tag] = { attributes: attrs, code: js };
            if (shouldSave) saveToStorage();
            return tag;
        }

        const s = document.createElement('script');
        s.innerHTML = js;
        document.head.appendChild(s);

        const el = document.createElement(tag);
        const attrs = el.constructor.observedAttributes || [];

        componentData[tag] = { attributes: attrs, code: js };
        if (shouldSave) saveToStorage();
        return tag;
    } catch (e) {
        console.error("Registration Error:", e);
        return null;
    }
}

function updateUI(app, tag) {
    const canvas = app.canvas;
    const controls = app.controls;

    canvas.updateStage(tag);
    controls.hide();

    if (tag) {
        controls.setTag(tag);
        const attrs = componentData[tag].attributes;
        const el = canvas.canvasStage.querySelector(tag);
        controls.renderAttributes(attrs, el);
        controls.show();
    }
}

function syncLibrary(app, active) {
    const canvas = app.canvas;
    const tags = Object.keys(componentData);
    canvas.syncSelector(tags, active);
}

function restoreFromHistory(app, history) {
    const codeRegex = /```(?:javascript|js)?\n?(.*?)```/gs;
    let lastTag = null;
    
    history.forEach(msg => {
        if (msg.role === 'ai') {
            const matches = msg.text.match(codeRegex);
            if (matches) {
                const code = matches[0].replace(/```(?:javascript|js)?/g, '').replace(/```$/g, '').trim();
                const tag = register(code);
                if (tag) lastTag = tag;
            }
        }
    });

    if (lastTag) {
        syncLibrary(app, lastTag);
        updateUI(app, lastTag);
    } else {
        syncLibrary(app, null);
    }
}

async function onSend(app, prompt) {
    console.log('onSend called with prompt:', prompt);
    const chat = app.chat;
    const canvas = app.canvas;

    chat.addMessage('user', prompt);
    chat.setSendDisabled(true);

    const loader = chat.addMessage('ai', '<i class="fas fa-circle-notch animate-spin mr-2"></i> Vibing...', true);

    try {
        const raw = await fetchAI(prompt);
        loader.remove();

        const codeRegex = /```(?:javascript|js)?\n?(.*?)```/gs;
        const matches = raw.match(codeRegex);
        if (matches) {
            const code = matches[0].replace(/```(?:javascript|js)?/g, '').replace(/```$/g, '').trim();
            try {
                new Function(code);
            } catch (e) {
                chat.addMessage('ai', 'Error: The generated code contains syntax errors and cannot be registered.');
                return;
            }
            const tag = register(code);
            if (tag) {
                chat.addMessage('ai', `<pre><code>${code}</code></pre>`);
                syncLibrary(app, tag);
                updateUI(app, tag);
                localStorage.setItem('vibe-coder-active-tag', tag);
            } else {
                chat.addMessage('ai', 'Error: Failed to register the generated component. Please check the code.');
            }
        } else {
            chat.addMessage('ai', raw);
        }
    } catch (error) {
        console.error(error);
        loader.remove();
        chat.addMessage('ai', 'Error: ' + error.message);
    } finally {
        chat.setSendDisabled(false);
    }
}

function init(app) {
    if (!app) {
        const appEl = document.querySelector('vibe-coder-app');
        if (appEl) {
            init(appEl);
        } else {
            document.addEventListener('DOMContentLoaded', () => {
                init(document.querySelector('vibe-coder-app'));
            });
        }
        return;
    }

    app.addEventListener('send-message', async (e) => {
        const text = e.detail.text;
        const chat = app.chat;

        chat.addMessage('user', text);
        const aiMsg = chat.addMessage('ai', 'Thinking...', true);

        try {
            const response = await fetchAI(text);
            aiMsg.removeAttribute('is-loading');
            aiMsg.setAttribute('text', encodeURIComponent(response));

            const tag = register(response);
            if (tag) {
                updateUI(app, tag);
            }
        } catch (err) {
            aiMsg.removeAttribute('is-loading');
            aiMsg.setAttribute('text', encodeURIComponent("Error: " + err.message));
        }
    });

    app.addEventListener('mode-change', (e) => {
        currentMode = e.detail.mode;
        console.log('Mode changed to:', currentMode.title);
        // Optionally notify the user or update UI
        app.chat.addMessage('ai', `Mode switched to **${currentMode.title}**: ${currentMode.description}`, false, true);
    });

    loadFromStorage();
}

// Initialize the app
init();




                            /**
 * <x-eyes> Web Component
 * A high-quality, reactive pair of eyes that follow the cursor.
 * 
 * Attributes:
 * - iris-color: The color of the eye's iris (e.g., "skyblue", "#ff0000").
 * - pupil-color: The color of the center pupil.
 * - eye-size: The diameter of the eyeball in pixels.
 */
class XEyes extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this._onMouseMove = this._onMouseMove.bind(this);
  }

  static get observedAttributes() {
    return ['iris-color', 'pupil-color', 'eye-size'];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;
    this._updateStyles();
  }

  connectedCallback() {
    this._render();
    window.addEventListener('mousemove', this._onMouseMove);
  }

  disconnectedCallback() {
    window.removeEventListener('mousemove', this._onMouseMove);
  }

  _render() {
    const irisColor = this.getAttribute('iris-color') || '#333';
    const pupilColor = this.getAttribute('pupil-color') || '#000';
    const eyeSize = this.getAttribute('eye-size') || '100';

    this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: inline-flex;
          gap: 20px;
          --iris-color: ${irisColor};
          --pupil-color: ${pupilColor};
          --eye-size: ${eyeSize}px;
          cursor: default;
        }

        .eye-socket {
          width: var(--eye-size);
          height: var(--eye-size);
          background: white;
          border-radius: 50%;
          position: relative;
          display: flex;
          align-items: center;
          justify-content: center;
          overflow: hidden;
          box-shadow: inset 0 0 10px rgba(0,0,0,0.1), 0 5px 15px rgba(0,0,0,0.2);
          border: calc(var(--eye-size) * 0.02) solid #ddd;
        }

        .iris {
          width: 40%;
          height: 40%;
          background: var(--iris-color);
          border-radius: 50%;
          position: absolute;
          display: flex;
          align-items: center;
          justify-content: center;
          transition: transform 0.05s linear;
          box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
        }

        .pupil {
          width: 50%;
          height: 50%;
          background: var(--pupil-color);
          border-radius: 50%;
        }

        .reflection {
          position: absolute;
          top: 15%;
          left: 15%;
          width: 25%;
          height: 25%;
          background: rgba(255, 255, 255, 0.4);
          border-radius: 50%;
        }
      </style>
      <div class="eye-socket">
        <div class="iris">
          <div class="pupil"></div>
          <div class="reflection"></div>
        </div>
      </div>
      <div class="eye-socket">
        <div class="iris">
          <div class="pupil"></div>
          <div class="reflection"></div>
        </div>
      </div>
    `;
  }

  _updateStyles() {
    if (!this.shadowRoot.firstElementChild) return;
    const style = this.shadowRoot.querySelector('style');
    const irisColor = this.getAttribute('iris-color') || '#333';
    const pupilColor = this.getAttribute('pupil-color') || '#000';
    const eyeSize = this.getAttribute('eye-size') || '100';

    this.style.setProperty('--iris-color', irisColor);
    this.style.setProperty('--pupil-color', pupilColor);
    this.style.setProperty('--eye-size', `${eyeSize}px`);
  }

  _onMouseMove(event) {
    const eyes = this.shadowRoot.querySelectorAll('.iris');
    const sockets = this.shadowRoot.querySelectorAll('.eye-socket');

    sockets.forEach((socket, i) => {
      const iris = eyes[i];
      const rect = socket.getBoundingClientRect();
      const eyeX = rect.left + rect.width / 2;
      const eyeY = rect.top + rect.height / 2;

      const angle = Math.atan2(event.clientY - eyeY, event.clientX - eyeX);
      const distance = Math.min(
        rect.width / 4, 
        Math.hypot(event.clientX - eyeX, event.clientY - eyeY) / 5
      );

      const x = Math.cos(angle) * distance;
      const y = Math.sin(angle) * distance;

      iris.style.transform = `translate(${x}px, ${y}px)`;
    });
  }
}

customElements.define('x-eyes', XEyes); 
                        


                            /**
 * VibeColorSwatch - A high-fidelity, reactive color display component.
 * Attributes:
 * - active-hex-color-code: The hex value to display (e.g., "#ff0055")
 * - descriptive-swatch-label: A human-readable title for the color
 * - show-metadata-overlay: Boolean attribute to toggle label visibility
 */
class VibeColorSwatch extends HTMLElement {
  static get observedAttributes() {
    return [
      'active-hex-color-code',
      'descriptive-swatch-label',
      'show-metadata-overlay'
    ];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this._render();
  }

  _render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: inline-block;
          font-family: 'Inter', system-ui, -apple-system, sans-serif;
          --swatch-size: 160px;
          --swatch-radius: 24px;
          --transition-speed: 0.4s;
          --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
        }

        .swatch-card {
          position: relative;
          width: var(--swatch-size);
          display: flex;
          flex-direction: column;
          gap: 12px;
          padding: 12px;
          background: #ffffff;
          border-radius: calc(var(--swatch-radius) + 8px);
          box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.05), 
                      0 8px 10px -6px rgba(0, 0, 0, 0.05);
          transition: transform var(--transition-speed) var(--ease-out-expo),
                      box-shadow var(--transition-speed) var(--ease-out-expo);
        }

        .swatch-card:hover {
          transform: translateY(-4px);
          box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 
                      0 10px 10px -6px rgba(0, 0, 0, 0.04);
        }

        .color-preview {
          width: 100%;
          aspect-ratio: 1 / 1;
          border-radius: var(--swatch-radius);
          background-color: var(--current-vibe-color, #cbd5e1);
          transition: background-color var(--transition-speed) var(--ease-out-expo);
          position: relative;
          overflow: hidden;
          border: 1px solid rgba(0,0,0,0.05);
        }

        .metadata-container {
          padding: 0 4px 4px 4px;
          display: flex;
          flex-direction: column;
          gap: 2px;
          opacity: 1;
          transition: opacity 0.3s ease;
        }

        .metadata-container.hidden {
          display: none;
        }

        .label-text {
          font-weight: 600;
          font-size: 0.85rem;
          color: #1e293b;
          margin: 0;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }

        .hex-value {
          font-family: 'JetBrains Mono', 'Fira Code', monospace;
          font-size: 0.7rem;
          color: #64748b;
          text-transform: uppercase;
          letter-spacing: 0.02em;
        }

        .gloss-effect {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 50%);
          pointer-events: none;
        }
      </style>
      
      <div class="swatch-card">
        <div class="color-preview" id="preview">
          <div class="gloss-effect"></div>
        </div>
        <div class="metadata-container" id="meta">
          <span class="label-text" id="label">Color Name</span>
          <span class="hex-value" id="hex">#000000</span>
        </div>
      </div>
    `;
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;

    const preview = this.shadowRoot.getElementById('preview');
    const label = this.shadowRoot.getElementById('label');
    const hex = this.shadowRoot.getElementById('hex');
    const meta = this.shadowRoot.getElementById('meta');

    switch (name) {
      case 'active-hex-color-code':
        const color = newValue || '#cbd5e1';
        preview.style.setProperty('--current-vibe-color', color);
        hex.textContent = color;
        break;
      case 'descriptive-swatch-label':
        label.textContent = newValue || 'Unnamed Vibe';
        break;
      case 'show-metadata-overlay':
        if (newValue === 'false') {
          meta.classList.add('hidden');
        } else {
          meta.classList.remove('hidden');
        }
        break;
    }
  }

  connectedCallback() {
    // Set defaults if attributes are missing
    if (!this.hasAttribute('active-hex-color-code')) {
      this.setAttribute('active-hex-color-code', '#6366f1');
    }
    if (!this.hasAttribute('descriptive-swatch-label')) {
      this.setAttribute('descriptive-swatch-label', 'Electric Indigo');
    }
  }
}

if (!customElements.get('vibe-color-swatch')) {
  customElements.define('vibe-color-swatch', VibeColorSwatch);
} 
                        