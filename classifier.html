<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Browser-Powered Semantic Search Demo</title>
  <!-- Local fonts: use system stack already defined in CSS variables; no external fonts -->
  <!-- Local CSV parser -->
  <script src="/deps/papaparse/papaparse-lite.js"></script>
  <!-- Local Transformers.js (ES module) -->
  <script type="module">
    import { pipeline, env } from '/deps/transformers/transformers.js';
    // Configure transformers to use local models and local WASM
    env.allowLocalModels = true;
    env.allowRemoteModels = false;
    env.useBrowserCache = false;
    // Point ONNX Runtime WASM to local copies
    env.backends = env.backends || {};
    env.backends.onnx = env.backends.onnx || { wasm: {} };
    env.backends.onnx.wasm = env.backends.onnx.wasm || {};
    env.backends.onnx.wasm.wasmPaths = {
      'ort-wasm.wasm': '/deps/transformers/dist/ort-wasm.wasm',
      'ort-wasm-simd.wasm': '/deps/transformers/dist/ort-wasm-simd.wasm',
      'ort-wasm-threaded.wasm': '/deps/transformers/dist/ort-wasm-threaded.wasm'
    };
    // Local models directory
    env.localModelPath = '/deps/models';
    // Expose globally for the page script to use
    window.transformers = { pipeline, env };
  </script>
  <style>
    :root{
      --bg:#f5f7fb; --card:#ffffff; --text:#0b1220; --muted:#5b6b78; --accent:#0066ff; --glass: rgba(255,255,255,0.6);
      --radius:12px; --mono: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
    }
    [data-theme="dark"]{
      --bg:#0b0f14; --card:#081019; --text:#e6eef8; --muted:#9fb0c8; --accent:#4aa3ff; --glass: rgba(255,255,255,0.04);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{font-family:var(--mono);margin:0;background:linear-gradient(180deg,var(--bg),#e9f0ff10);color:var(--text);-webkit-font-smoothing:antialiased}
    .container{max-width:1100px;margin:32px auto;padding:20px}
    header.hero{display:flex;gap:18px;align-items:center;justify-content:space-between}
    .title{margin:0}
    h1{font-size:20px;margin:0 0 6px}
    p.lead{margin:0;color:var(--muted)}
    .layout{display:grid;grid-template-columns:1fr 320px;gap:20px;margin-top:20px}
    @media(max-width:900px){.layout{grid-template-columns:1fr}}
    .card{background:var(--card);border-radius:var(--radius);padding:16px;box-shadow:0 6px 18px rgba(10,15,30,0.06);border:1px solid rgba(0,0,0,0.04)}
    .upload-card{display:flex;flex-direction:column;gap:12px}
    input[type=file]{display:block}
    .row{display:flex;gap:8px;align-items:center}
    .btn{background:var(--accent);color:white;padding:10px 12px;border-radius:10px;border:0;cursor:pointer;font-weight:600}
    .btn.ghost{background:transparent;border:1px solid rgba(0,0,0,0.06);color:var(--text)}
    .muted{color:var(--muted);font-size:13px}
    .progress{height:10px;background:linear-gradient(90deg,#e6eef8,#ffffff);border-radius:10px;overflow:hidden}
    .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#00c6ff);width:0%;transition:width 300ms ease}
    .summary{margin-top:8px;padding:10px;border-radius:10px;background:var(--glass);font-size:14px}
    textarea{width:100%;min-height:120px;padding:12px;border-radius:10px;border:1px solid rgba(0,0,0,0.06);resize:vertical;background:transparent;color:var(--text)}
    .results{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;margin-top:12px}
    .result{padding:12px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border:1px solid rgba(0,0,0,0.04);opacity:0;transform:translateY(8px);animation:fadeIn 360ms forwards}
    @keyframes fadeIn{to{opacity:1;transform:none}}
    .score{font-weight:700}
    footer{margin-top:22px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .badge{padding:6px 8px;border-radius:8px;background:var(--glass);font-size:13px}
    .sidebar .meta{font-size:13px;color:var(--muted)}
    .small{font-size:13px}
    .topbar{display:flex;gap:12px;align-items:center}
    .toggle{padding:6px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);cursor:pointer}
    .link{color:var(--accent);text-decoration:none}
    .kbd{background:#111;color:#fff;padding:4px 6px;border-radius:6px;font-size:12px}
    .controls{display:flex;gap:8px}
    .danger{background:transparent;border:1px solid #ff6b6b;color:#ff6b6b}
    .spinner{width:18px;height:18px;border-radius:50%;border:2px solid rgba(0,0,0,0.1);border-top-color:var(--accent);animation:spin 900ms linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>
<body data-theme="light">
  <div class="container">
    <header class="hero">
      <div>
        <h1 class="title">Browser-Powered Semantic Search Demo</h1>
        <p class="lead">Upload your data, query with natural languageâ€”powered by Transformers.js &amp; IndexedDB.</p>
      </div>
      <div class="topbar">
        <div class="small muted" id="timing">Embeddings: â€”</div>
        <button class="toggle" id="themeToggle" aria-pressed="false" title="Toggle theme">ðŸŒ™</button>
      </div>
    </header>

    <main class="layout" role="main">
      <section>
        <div class="card upload-card" aria-labelledby="uploadHeading">
          <h3 id="uploadHeading">Upload CSV (key,value)</h3>
          <div class="muted">Expect exactly two columns: <strong>key</strong> (string) and <strong>value</strong> (text). Rows will be embedded on-device.</div>

          <div class="row" style="align-items:center;margin-top:8px">
            <input id="csvFile" type="file" accept="text/csv" aria-label="Upload CSV file" />
            <div class="controls">
              <button class="btn" id="loadSample">Load Sample</button>
              <button class="btn ghost" id="clearDB">Clear Database</button>
            </div>
          </div>

          <div style="margin-top:12px">
            <div class="progress" aria-hidden="true"><i id="progressBar"></i></div>
            <div class="summary" id="summary">No data loaded.</div>
            <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
              <div id="uploadSpinner" style="display:none" class="spinner" role="status" aria-hidden="true"></div>
              <div class="muted small">Model: <strong>Xenova/all-MiniLM-L6-v2</strong></div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:14px" aria-labelledby="queryHeading">
          <h3 id="queryHeading">Query Input</h3>
          <textarea id="query" placeholder="Enter a query to find semantically similar entries..." aria-label="Query input"></textarea>
          <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
            <button class="btn" id="classify">Classify &amp; Match</button>
            <input id="topK" type="number" min="1" max="20" value="5" style="width:72px;padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06)" aria-label="Top K results" />
            <button class="btn ghost" id="clearResults">Clear Results</button>
            <div id="querySpinner" style="display:none" class="spinner" role="status" aria-hidden="true"></div>
          </div>
        </div>

        <div id="resultsCard" class="card" style="margin-top:14px;display:block">
          <h3>Results</h3>
          <div id="results" class="results" aria-live="polite"></div>
        </div>
      </section>

      <aside class="sidebar card" style="height:fit-content">
        <h4>Tech Spotlight</h4>
        <div class="meta">Embeddings computed on-device with Transformers.js. Stored locally with IndexedDB.</div>
        <hr style="margin:12px 0">
        <div style="display:flex;flex-direction:column;gap:8px">
          <div><strong id="lastEmbedCount">â€”</strong> entries stored</div>
          <div class="small muted">Last embed time: <span id="lastEmbedTime">â€”</span> ms</div>
          <div class="small muted">Last query time: <span id="lastQueryTime">â€”</span> ms</div>
        </div>
        <hr style="margin:12px 0">
        <div style="display:flex;flex-direction:column;gap:8px">
          <div class="small">Keyboard: <span class="kbd">Tab</span> navigation supported.</div>
          <div class="small">Try sample: "fruit" or "fast vehicle"</div>
        </div>
        <footer style="margin-top:12px">
          <a class="badge" href="https://huggingface.co/xenova/all-MiniLM-L6-v2" target="_blank" rel="noopener">Model</a>
          <a class="badge" href="https://xenova.ai/transformers.js" target="_blank" rel="noopener">Transformers.js</a>
          <a class="badge" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">IndexedDB</a>
        </footer>
      </aside>
    </main>

    <footer class="container" style="max-width:1100px;">
      <div class="card" style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <strong>Stack:</strong> Transformers.js â€¢ PapaParse â€¢ IndexedDB â€¢ Vanilla JS
        </div>
        <div style="display:flex;gap:8px">
          <a class="link" href="#">Docs</a>
        </div>
      </div>
    </footer>
  </div>

  <script>
  // Global error hook to display script errors in the UI for easier debugging.
  window.addEventListener('error', (ev) => {
    try{
      const summary = document.getElementById('summary');
      if(summary) summary.textContent = 'Script error: ' + (ev.message || 'Unknown error');
      console.error('Global error captured:', ev.error || ev.message, ev);
    }catch(e){ console.error('Error handler failed', e); }
  });

  // === Utility: IndexedDB wrapper ===
  const DB_NAME = 'VectorDB';
  const STORE_NAME = 'embeddings';
  function openDB(){
    return new Promise((resolve, reject) => {
      try{
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = (e) => {
          const db = e.target.result;
          if(!db.objectStoreNames.contains(STORE_NAME)){
            db.createObjectStore(STORE_NAME, { keyPath: 'key' });
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error || new Error('IndexedDB open failed'));
      }catch(err){ reject(err); }
    });
  }
  async function putMany(entries){
    const db = await openDB();
    return new Promise((resolve,reject)=>{
      try{
        const tx = db.transaction(STORE_NAME,'readwrite');
        const store = tx.objectStore(STORE_NAME);
        for(const e of entries) store.put(e);
        tx.oncomplete = ()=>resolve();
        tx.onerror = ()=>reject(tx.error || new Error('Transaction failed'));
      }catch(err){ reject(err); }
    })
  }
  async function getAll(){
    const db = await openDB();
    return new Promise((resolve,reject)=>{
      try{
        const tx = db.transaction(STORE_NAME,'readonly');
        const store = tx.objectStore(STORE_NAME);
        const req = store.getAll();
        req.onsuccess = ()=>resolve(req.result || []);
        req.onerror = ()=>reject(req.error || new Error('getAll failed'));
      }catch(err){ reject(err); }
    })
  }
  async function clearDB(){
    const db = await openDB();
    return new Promise((resolve,reject)=>{
      try{
        const tx = db.transaction(STORE_NAME,'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const req = store.clear();
        req.onsuccess = ()=>resolve();
        req.onerror = ()=>reject(req.error || new Error('clear failed'));
      }catch(err){ reject(err); }
    })
  }

  // === UI elements ===
  const csvFile = document.getElementById('csvFile');
  const progressBar = document.getElementById('progressBar');
  const summary = document.getElementById('summary');
  const uploadSpinner = document.getElementById('uploadSpinner');
  const classifyBtn = document.getElementById('classify');
  const querySpinner = document.getElementById('querySpinner');
  const queryInput = document.getElementById('query');
  const resultsEl = document.getElementById('results');
  const clearResultsBtn = document.getElementById('clearResults');
  const clearDBBtn = document.getElementById('clearDB');
  const topKInput = document.getElementById('topK');
  const lastEmbedCount = document.getElementById('lastEmbedCount');
  const lastEmbedTime = document.getElementById('lastEmbedTime');
  const lastQueryTime = document.getElementById('lastQueryTime');
  const timing = document.getElementById('timing');
  const loadSample = document.getElementById('loadSample');

  // === Transformers pipeline ===
  let embedder = null;
  async function ensureModel(){
    if(embedder) return embedder;
    // Defensive check: ensure transformers is available
    if(!window.transformers){
      throw new Error('Transformers.js library not loaded. Check local reference.');
    }
    timing.textContent = 'Loading model...';
    try{
  // Use the feature-extraction pipeline with local model files only.
  embedder = await window.transformers.pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
      timing.textContent = 'Model loaded.';
      return embedder;
    }catch(err){
      timing.textContent = 'Model load failed.';
      console.error('Model load error', err);
      throw err;
    }
  }

  // Convert Float32Array (or numeric[]) to plain array for JSON store
  function vecToJSONFloat(arr){
    if(arr instanceof Float32Array) return Array.from(arr);
    if(Array.isArray(arr)) return arr;
    return Array.from(new Float32Array(arr));
  }
  function jsonToFloat32(arr){
    return new Float32Array(arr);
  }

  // cosine similarity
  function cosine(a,b){
    if(!a || !b || a.length !== b.length) return 0;
    let sum=0, na=0, nb=0;
    for(let i=0;i<a.length;i++){ const x=+a[i]||0, y=+b[i]||0; sum += x*y; na += x*x; nb += y*y }
    if(na===0 || nb===0) return 0;
    return sum / (Math.sqrt(na)*Math.sqrt(nb));
  }

  // Embedding pipeline for batch of texts
  async function embedBatch(texts){
    await ensureModel();
    // embedder may return arrays directly or objects; handle shapes robustly
    const results = await embedder(texts);
    // If model returns an object like {data: [...]}
    let out = results;
    if(results && typeof results === 'object' && Array.isArray(results.data)) out = results.data;
    if(!Array.isArray(out)) throw new Error('Unexpected embedding result shape');

    return out.map(r => {
      if(!r) return new Float32Array();
      // normalize possible token vectors -> if r[0] is array, average tokens
      if(Array.isArray(r) && Array.isArray(r[0])){
        const len = r.length;
        const dim = r[0].length;
        const acc = new Float32Array(dim);
        for(let i=0;i<len;i++) for(let j=0;j<dim;j++) acc[j]+= (r[i][j] || 0);
        for(let j=0;j<dim;j++) acc[j] /= len;
        return acc;
      }
      // if already flat numeric array
      if(Array.isArray(r)) return new Float32Array(r.map(v=>+v||0));
      // if already typed array
      if(r instanceof Float32Array) return r;
      // fallback: try to coerce
      return new Float32Array(Array.from(r));
    });
  }

  // Helper: set progress safely
  function setProgress(pct){
    try{ if(progressBar) progressBar.style.width = (pct<0?0: pct>100?100:pct) + '%'; }catch(e){}
  }

  // Handle CSV upload
  csvFile.addEventListener('change', async (e)=>{
    const file = e.target.files && e.target.files[0];
    if(!file) return;
    try{
      uploadSpinner.style.display='inline-block';
      summary.textContent = 'Parsing CSV...';
      const text = await file.text();
      const parsed = Papa.parse(text.trim(), {header:true, skipEmptyLines:true});
      if(parsed.errors && parsed.errors.length){
        console.error(parsed.errors);
        summary.textContent = 'CSV parse error: ' + parsed.errors[0].message;
        uploadSpinner.style.display='none';
        return;
      }
      const rows = parsed.data;
      if(!rows || !rows.length){ summary.textContent='CSV is empty.'; uploadSpinner.style.display='none'; return; }
      // Validate columns - tolerant to whitespace/case
      const first = rows[0];
      const cols = Object.keys(first).map(k=>k.trim().toLowerCase());
      if(!cols.includes('key') || !cols.includes('value')){
        summary.textContent = 'Invalid CSV columns. Expect columns named "key" and "value".';
        uploadSpinner.style.display='none';
        return;
      }
      const prepared = rows.map(r=>({key: String(r.key), value: String(r.value)}));
      const BATCH = 32;
      let processed = 0;
      const start = performance.now();
      const entriesToStore = [];
      for(let i=0;i<prepared.length;i+=BATCH){
        const batch = prepared.slice(i,i+BATCH);
        setProgress(Math.round((i/prepared.length)*100));
        summary.textContent = `Embedding ${Math.min(i+BATCH, prepared.length)} / ${prepared.length}`;
        try{
          const texts = batch.map(b=>b.value);
          const vecs = await embedBatch(texts); // Embedding pipeline
          for(let j=0;j<vecs.length;j++){
            entriesToStore.push({ key: batch[j].key, value: batch[j].value, embedding: vecToJSONFloat(vecs[j]) });
          }
        }catch(err){
          console.error('Embedding failure',err);
          summary.textContent = 'Embedding failed: ' + String(err.message || err);
          uploadSpinner.style.display='none';
          return;
        }
        processed += batch.length;
        setProgress(Math.round((processed/prepared.length)*100));
        // allow UI update
        await new Promise(r=>setTimeout(r,40));
      }
      summary.textContent = 'Storing embeddings locally...';
      await putMany(entriesToStore);
      const end = performance.now();
      setProgress(100);
      const elapsed = Math.round(end-start);
      summary.textContent = `Loaded ${entriesToStore.length} entries into local vector index in ${elapsed} ms.`;
      lastEmbedCount.textContent = entriesToStore.length;
      lastEmbedTime.textContent = elapsed;
      timing.textContent = `Embeddings computed on-device in ${elapsed} ms`;
    }catch(err){
      console.error(err);
      summary.textContent = 'Unexpected error: ' + String(err.message || err);
    }finally{ uploadSpinner.style.display='none'; setTimeout(()=>setProgress(0),600); }
  });

  // Load sample
  loadSample.addEventListener('click', async ()=>{
    const csv = `key,value\napple,Red fruit that grows on trees.\nbanana,Yellow curved tropical fruit.\ncar,Vehicle with four wheels.\nplane,Fast flying vehicle.\ntruck,Large vehicle for transport.`;
    const parsed = Papa.parse(csv, {header:true});
    csvFile.value = null;
    try{
      uploadSpinner.style.display='inline-block';
      const rows = parsed.data;
      const prepared = rows.map(r=>({key: String(r.key), value: String(r.value)}));
      const BATCH = 16;
      const entriesToStore = [];
      const start = performance.now();
      for(let i=0;i<prepared.length;i+=BATCH){
        const batch = prepared.slice(i,i+BATCH);
        setProgress(Math.round((i/prepared.length)*100));
        summary.textContent = `Embedding ${Math.min(i+BATCH, prepared.length)} / ${prepared.length}`;
        const vecs = await embedBatch(batch.map(b=>b.value));
        for(let j=0;j<vecs.length;j++) entriesToStore.push({key:batch[j].key,value:batch[j].value,embedding:vecToJSONFloat(vecs[j])});
        await new Promise(r=>setTimeout(r,40));
      }
      await putMany(entriesToStore);
      const end = performance.now();
      const elapsed = Math.round(end-start);
      setProgress(100);
      summary.textContent = `Loaded ${entriesToStore.length} sample entries into local vector index in ${elapsed} ms.`;
      lastEmbedCount.textContent = entriesToStore.length;
      lastEmbedTime.textContent = elapsed;
      timing.textContent = `Embeddings computed on-device in ${elapsed} ms`;
    }catch(err){ summary.textContent = 'Sample load failed: '+(err.message||err); console.error(err); }
    finally{ uploadSpinner.style.display='none'; setTimeout(()=>setProgress(0),600); }
  });

  // Clear database
  clearDBBtn.addEventListener('click', async ()=>{
    if(!confirm('Clear all embeddings from IndexedDB?')) return;
    try{ await clearDB(); summary.textContent='Database cleared.'; lastEmbedCount.textContent='0'; }catch(err){ summary.textContent='Clear failed: '+(err.message||err); }
  });

  // Classify & Match
  classifyBtn.addEventListener('click', async ()=>{
    const q = (queryInput.value||'').trim();
    if(!q){ alert('Please enter a query.'); return; }
    let stored = [];
    try{ stored = await getAll(); }catch(err){ summary.textContent='Failed to read DB: ' + (err.message||err); return; }
    if(!stored.length){ alert('No data loaded. Please upload a CSV first.'); return; }
    querySpinner.style.display='inline-block';
    resultsEl.innerHTML='';
    try{
      const start = performance.now();
      const qvecs = await embedBatch([q]);
      const qvec = qvecs[0];
      // compute similarities
      const candidates = stored.map(s => ({key:s.key,value:s.value,vec:jsonToFloat32(s.embedding)}));
      const scored = candidates.map(c => ({...c, score: cosine(qvec,c.vec)}));
      scored.sort((a,b)=>b.score - a.score);
      const K = Math.max(1, Math.min(20, parseInt(topKInput.value)||5));
      const top = scored.slice(0,K);
      // render
      for(const r of top){
        const card = document.createElement('div'); card.className='result';
        const pct = Math.round((r.score||0)*1000)/10;
        card.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700">${escapeHtml(r.key)}</div><div class="score">${pct}%</div></div><div style="margin-top:8px" class="muted">${escapeHtml(r.value)}</div>`;
        resultsEl.appendChild(card);
      }
      const end = performance.now();
      const qtime = Math.round(end-start);
      lastQueryTime.textContent = qtime;
      timing.textContent = `Query executed in ${qtime} ms`;
    }catch(err){ console.error(err); summary.textContent='Query failed: '+(err.message||err); }
    finally{ querySpinner.style.display='none'; }
  });

  // Clear results
  clearResultsBtn.addEventListener('click', ()=>{ resultsEl.innerHTML=''; });

  // small helper
  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // Theme toggle
  const themeToggle = document.getElementById('themeToggle');
  themeToggle.addEventListener('click', ()=>{
    const el = document.body;
    const cur = el.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
    const next = cur === 'dark' ? 'light' : 'dark';
    el.setAttribute('data-theme', next);
    themeToggle.textContent = next === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™';
    themeToggle.setAttribute('aria-pressed', String(next==='dark'));
  });

  // On load: try to show stored count
  (async ()=>{
    try{ const stored = await getAll(); lastEmbedCount.textContent = stored.length || 0; summary.textContent = stored.length?`Loaded ${stored.length} entries from local DB.` : 'No data loaded.'; }catch(e){ console.warn('DB not ready',e); }
  })();

  // README comment block for extension
  /*
  README:
  - Save this file as index.html and open in a modern browser (Chrome/Firefox/Safari).
  - Upload a CSV with columns: key,value. The app embeds each "value" with Xenova/all-MiniLM-L6-v2 via Transformers.js and stores vectors in IndexedDB.
  - Click "Classify & Match" after loading data to run semantic search. Adjust K for number of results.
  - If you encounter a "Script error" see the summary banner for details. Common causes: blocked CDN, model download blocked by CORS, or network failure. Ensure external scripts can be loaded.
  - To swap models, change the model string in ensureModel() to another model available for feature-extraction in Transformers.js.
  - For production: add better chunking for very large CSVs, streaming writes to IndexedDB, and optional quantization to reduce storage size.
  */
  </script>
</body>
</html>
